package migrations

import (
	"fmt"

	"go.uber.org/zap"

	"github.com/spacemeshos/go-spacemesh/common/types"
	"github.com/spacemeshos/go-spacemesh/sql"
)

type migration0018 struct {
	logger *zap.Logger
}

func New0018Migration(log *zap.Logger) *migration0018 {
	return &migration0018{
		logger: log,
	}
}

func (*migration0018) Name() string {
	return "add malfeasance proofs for incorrect prevATXID in ATXs"
}

func (*migration0018) Order() int {
	return 18
}

func (*migration0018) Rollback() error {
	// handled by the DB itself
	return nil
}

func (m *migration0018) Apply(db sql.Executor) error {
	found, err := m.findMaliciousATXs(db)
	if err != nil {
		return fmt.Errorf("error finding malfeasant ATXs: %w", err)
	}

	for _, collision := range found {
		if m.isIdentityMalicious(collision.id) {
			continue
		}

		// if err := m.createMalfeasanceProof(db, collision); err != nil {
		// 	return fmt.Errorf("error creating malfeasance proof: %w", err)
		// }
	}

	return nil
}

type prevATXCollision struct {
	id   types.NodeID
	atx1 []byte
	atx2 []byte
}

func (m *migration0018) findMaliciousATXs(db sql.Executor) ([]prevATXCollision, error) {
	var result []prevATXCollision

	dec := func(stmt *sql.Statement) bool {
		var id types.NodeID
		stmt.ColumnBytes(0, id[:])

		var id1, id2 types.ATXID
		stmt.ColumnBytes(1, id1[:])
		stmt.ColumnBytes(2, id2[:])

		m.logger.Debug("found ATXs with same prevATX",
			zap.String("node_id", id.String()),
			zap.String("atx1", id1.ShortString()),
			zap.String("atx2", id2.ShortString()),
		)

		data1 := make([]byte, stmt.ColumnLen(3))
		data2 := make([]byte, stmt.ColumnLen(4))
		stmt.ColumnBytes(3, data1)
		stmt.ColumnBytes(4, data2)

		result = append(result, prevATXCollision{
			id:   id,
			atx1: data1,
			atx2: data2,
		})
		return true
	}
	if _, err := db.Exec(`
		SELECT t1.pubkey, t1.id, t2.id, t3.atx, t4.atx
		FROM atxs t1
		JOIN atxs t2 ON t1.pubkey = t2.pubkey AND t1.prev_id = t2.prev_id
		JOIN atxs_blobs t3 ON t1.id = t3.id
		JOIN atxs_blobs t4 ON t2.id = t4.id
		WHERE t1.id <> t2.id;`, nil, dec); err != nil {
		return nil, fmt.Errorf("error getting ATXs with same prevATX: %w", err)
	}

	return result, nil
}

func (m *migration0018) isIdentityMalicious(nodeID types.NodeID) bool {
	return false
}

// func (m *migration0018) createMalfeasanceProof(db sql.Executor, collisions []prevATXCollision) error {
// 	var wireAtx1 wire.ActivationTxV1
// 		if err := codec.Decode(data1, &wireAtx1); err != nil {
// 			m.logger.Error("failed to decode ATX1", zap.Error(err))
// 			return false
// 		}

// 		var wireAtx2 wire.ActivationTxV1
// 		if err := codec.Decode(data2, &wireAtx2); err != nil {
// 			m.logger.Error("failed to decode ATX2", zap.Error(err))
// 			return false
// 		}

// 		proof := &mwire.MalfeasanceProof{
// 			Layer: m.clock.GetCurrentLayer(),
// 			Proof: mwire.Proof{
// 				Type: mwire.InvalidPrevATX,
// 				Data: &mwire.InvalidPrevATXProof{
// 					Atx1: wireAtx1,
// 					Atx2: wireAtx2,
// 				},
// 			},
// 		}

// 		encoded, err := codec.Encode(proof)
// 		if err != nil {
// 			m.logger.Error("failed to encode malfeasance proof", zap.Error(err))
// 			return false
// 		}
// 	}
// }
