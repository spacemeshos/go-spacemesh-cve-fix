package activation

import (
	"context"
	"time"

	"github.com/spacemeshos/go-spacemesh/codec"
	"github.com/spacemeshos/go-spacemesh/common/types"
	"github.com/spacemeshos/go-spacemesh/log"
	"github.com/spacemeshos/go-spacemesh/malfeasance/wire"
	"github.com/spacemeshos/go-spacemesh/p2p/pubsub"
	"github.com/spacemeshos/go-spacemesh/sql/atxs"
	"github.com/spacemeshos/go-spacemesh/sql/builder"
	"github.com/spacemeshos/go-spacemesh/sql/identities"
)

// verifyDB performs a verification of prev ATXs of ATXs in DB.
func (h *Handler) VerifyATXs(ctx context.Context) error {
	start := time.Now() // TODO(mafa): check in local db from where to start

	total, err := atxs.CountAtxsByOps(h.cdb, builder.Operations{
		Filter: []builder.Op{{
			Field: builder.Received,
			Token: builder.Lte,
			Value: start.UnixNano(),
		}},
		Modifiers: []builder.Modifier{{
			Key:   builder.OrderBy,
			Value: "received desc",
		}},
	})
	if err != nil {
		h.log.With().Error("failed to count ATXs", log.Err(err))
	}

	h.log.Info("verifying %d ATXs stored in state database (from %s to genesis)", total, start)
	count := 0

	// check ATX signatures
	err = atxs.IterateAtxsOps(h.cdb, builder.Operations{}, func(atx *types.VerifiedActivationTx) bool {
		select {
		case <-ctx.Done():
			// stop on context cancellation
			return false
		default:
		}

		malicious, err := identities.IsMalicious(h.cdb, atx.SmesherID)
		if err != nil {
			h.log.With().Error("failed to get malicious status", log.Err(err))
			return false
		}
		if malicious {
			// we already have a malfeasance proof for this smesher, no need to create another
			return true
		}

		proof, err := h.checkWrongPrevAtx(ctx, h.cdb, atx)
		if err != nil {
			h.log.With().Error("failed to check wrong prev ATX", log.Err(err))
			return false
		}
		if proof != nil {
			h.cdb.CacheMalfeasanceProof(atx.SmesherID, proof)
			h.tortoise.OnMalfeasance(atx.SmesherID)

			gossip := wire.MalfeasanceGossip{
				MalfeasanceProof: *proof,
			}
			encodedProof := codec.MustEncode(&gossip)
			if err = h.publisher.Publish(ctx, pubsub.MalfeasanceProof, encodedProof); err != nil {
				h.log.With().Error("failed to broadcast malfeasance proof", log.Err(err))
				return false
			}
		}

		// on windows timestamps have bad resolution
		// this makes sure we don't skip any that were received "at the same time"
		// at the cost of possibly checking a few ATXs again if we abort early
		start = atx.Received().Add(time.Second)
		count++
		if count%5000 == 0 {
			h.log.Info("verifying ATXs in state db: %d / %d", count, total)
		}
		return true
	})
	if err != nil {
		h.log.With().Error("failed to iterate ATXs", log.Err(err))
		h.log.With().Info("ATX verification aborted", log.Int("count", count), log.Int("total", int(total)))
		return nil
	}

	h.log.Info("all ATXs verified", log.Int("count", count))
	return nil
}
