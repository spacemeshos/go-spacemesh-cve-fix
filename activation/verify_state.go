package activation

import (
	"context"
	"fmt"
	"time"

	"go.uber.org/zap"

	awire "github.com/spacemeshos/go-spacemesh/activation/wire"
	"github.com/spacemeshos/go-spacemesh/codec"
	"github.com/spacemeshos/go-spacemesh/malfeasance/wire"
	"github.com/spacemeshos/go-spacemesh/sql"
	"github.com/spacemeshos/go-spacemesh/sql/atxs"
	"github.com/spacemeshos/go-spacemesh/sql/identities"
)

func CheckPrevATXs(ctx context.Context, logger *zap.Logger, db sql.Executor) error {
	collisions, err := atxs.PrevATXCollisions(db)
	if err != nil {
		return fmt.Errorf("get prev ATX collisions: %w", err)
	}

	logger.Info("found ATX collisions", zap.Int("count", len(collisions)))
	count := 0
	for _, collision := range collisions {
		select {
		case <-ctx.Done():
			// stop on context cancellation
			return ctx.Err()
		default:
		}

		malicious, err := identities.IsMalicious(db, collision.NodeID)
		if err != nil {
			return fmt.Errorf("get malicious status: %w", err)
		}

		if malicious {
			// already malicious no need to generate proof
			continue
		}

		var atx1 awire.ActivationTxV1
		codec.MustDecode(collision.Atx1, &atx1)

		var atx2 awire.ActivationTxV1
		codec.MustDecode(collision.Atx1, &atx2)

		proof := &wire.MalfeasanceProof{
			Layer: atx1.Publish.FirstLayer(),
			Proof: wire.Proof{
				Type: wire.InvalidPrevATX,
				Data: &wire.InvalidPrevATXProof{
					Atx1: atx1,
					Atx2: atx2,
				},
			},
		}

		encodedProof := codec.MustEncode(proof)
		if err := identities.SetMalicious(db, collision.NodeID, encodedProof, time.Now()); err != nil {
			return fmt.Errorf("add malfeasance proof: %w", err)
		}

		// h.cdb.CacheMalfeasanceProof(atx.SmesherID, proof)
		// h.tortoise.OnMalfeasance(atx.SmesherID)

		// if err = h.publisher.Publish(ctx, pubsub.MalfeasanceProof, encodedProof); err != nil {
		// 	h.log.With().Error("failed to broadcast malfeasance proof", log.Err(err))
		// 	return false
		// }

		count++
	}
	logger.Info("created malfeasance proofs", zap.Int("count", count))
	return nil
}
